# 实验2 栈的应用记录

## 题目理解

这次实验分成两个小问题：  
1. 用算符优先法计算一个中缀表达式，并把计算时两个栈的变化过程打印出来。  
2. 骑士巡逻问题要各实现一份递归版本和非递归版本，输出走法。  

老师要求不能用 STL，于是我直接用 C 语言写了手工栈和棋盘数组，感觉更直接一点。

这次把两个问题分别写成了两个程序：  
- `Project/expr_eval.c` 负责读表达式并演示两个栈的变化；  
- `Project/knight_tour.c` 里放了递归版和非递归版的骑士巡逻菜单。  

## 表达式求值

### 思路

课堂上讲的算符优先法主要靠两个栈：操作符栈和操作数栈。栈顶的运算符和当前读到的运算符通过一个优先级表比较，决定是推入还是弹出计算。我照着 PPT 的优先级表手敲了一份二维数组，顺序是 `+ - * / ( ) =`。  

具体操作时做了几点处理：

- 输入用 `fgets` 读整行，缺少结尾的 `=` 的话我自动补一个，免得出错。  
- 由于不能用字符串类，数字解析就自己写了一个循环，把多位正整数拼起来。  
- 每一步都调用 `show_expression_state` 打印四项信息：操作符栈内容、操作数栈内容、当前处理的字符和说明文字。说明文字暂时就用了“读入运算符”“进行一次计算”等。  
- 计算部分只考虑 `+ - * /`。除法如果遇到除数为 0，我让它直接返回 0，不然程序会崩。  

### 小结

实际跑的时候能看到两个栈怎么一层一层变化，对理解教材里的例子挺有帮助。不过也能感觉到，如果想支持更多运算（比如一元运算或者浮点数），这个实现要再改一大轮。

## 骑士巡逻

### 输入约定

为了简单，棋盘最大只做到 8×8，这样一个整型数组就够用了。用户输入 `n` 和起点 `(x, y)`，坐标都是从 1 开始的，我在程序里减一转换成 0 下标。

### 递归版本

递归的框架很直接：先把当前位置标记为当前步数，然后尝试 8 种跳法。跳到新位置后递归调用，如果深层递归返回成功就一直往外传。所有跳法都失败时把格子清零，走回上一层。  

这里我把棋盘做成全局数组 `board_recursive`，递归函数里就不用反复传指针了。

### 非递归版本

非递归版本我用一个简单的结构体栈来模拟函数调用。每个栈帧保存当前格子的坐标以及下一个要尝试的跳法编号 `next_move`。流程大概是：

1. 把起点压栈，步数设为 1。  
2. 如果当前帧的 `next_move` 已经等于 8，说明八个方向都试过了，需要回溯：当前格子清零，出栈，步数减一。  
3. 否则取出第 `next_move` 个方向，先把 `next_move` 自增，这样回溯回来就会接着试下一种。若目标格没访问过，就压入新帧并给棋盘写入步数。  
4. 循环直到步数达到 `n*n`（找到一条路径）或者栈空（无解）。  

这种写法虽然麻烦一点，但逻辑上和递归版一一对应，也能更直观地看到回溯过程其实就是数据结构栈在起作用。

### 结果展示

在 5×5 棋盘、起点 (1,1) 的情况下，两种方法都输出了同一条路径：

```
 1  6 15 10 21
14  9 20  5 16
19  2  7 22 11
 8 13 24 17  4
25 18  3 12 23
```

如果换成更大的棋盘或者比较刁钻的起点，有时候会找不到解，程序会提示“没有找到路线”。

## 遇到的问题与反思

- 写表达式求值的时候，`=` 作为栈底哨兵比较特殊，第一次运行的时候提示语句老说“匹配括号”，后来加了一个判断才区分出是结束标记还是右括号。  
- 骑士巡逻这题如果想提高成功率，最好加 Warnsdorff 规则之类的“贪心”策略，但这次实验要求不高，就先保持最基础的深度优先。  
- 目前的代码全是顺序表，没有做越界保护，如果输入超长表达式或者棋盘要超过 8×8 就直接被限制掉了。后续如果真要提交报告的话，应该在说明里明写这些限制。  

整体来说，两个小程序都能运行，打印信息比较详细，符合“栈的应用”这个主题。编译时分别执行 `gcc expr_eval.c -o expr_eval` 和 `gcc knight_tour.c -o knight_tour`，运行后跟着菜单操作即可。
